\section{Introduction to STE}

\subsection{Original STE}

\textit{Symbolic trajectory evaluation}~\cite{seger1995} (STE) is a high-performance model checking technique based on \textit{symbolic simulation} extended with a temporal \textit{next-time} operator to describe circuit behaviour over time. In its simplest form, STE tests the validity of an \textit{assertion} of the form $A \Rightarrow C$, where both the \textit{antecedent} $A$ and \textit{consequent} $C$ are formulas in the following logic:

\begin{equation*}
f ::= p \: | \: f \wedge f \: | \: P \rightarrow f \: | \: \Next f
\end{equation*}

\noindent Here, $p$ is a simple predicate over ``values'' in a circuit and $P$ is a Boolean propositional formula, and the operators $\wedge$, $\rightarrow$ and $\Next$ are conjunction, domain restriction and the next-time operator, respectively.

If the circuit contains Boolean signals, $p$ is typically drawn from the following two predicates: $n \Is 1$ and $n \Is 0$, where $n$ ranges over the signals (or nodes) in a circuit. For example, suppose we have a unit-delayed, two-input AND-gate, then it is reasonable to assume that the assertion $(\mathit{in_{1}} \Is 1 \wedge \mathit{in_{2}} \Is 1) \Rightarrow \Next (\mathit{out} \Is 1)$ is true. Indeed, STE efficiently validates such statements for us.

While the truth semantics of an assertion in STE is defined as the satisfaction of its ``defining'' trajectory (bounded sequence of states) relative to a model structure of the circuit, what the STE algorithm computes is exactly the solution of a data-flow equation~\cite{chou1999} in the classic format~\cite{muchnick1997}. \dots

% translate an STE assertion into a linear, directed graph \dots introducing as many states as the assertion is deep \dots labelling each state with the antecedent and consequent at that depth. \dots

% We adopt this reimagined STE as data flow analysis~\cite{chou1999}, in which trajectory assertions can have arbitrary state-transition graphs. The following sections give a short introduction to its mathematical foundation.

\subsection{Set-theoretic STE}

Consider an arbitrary, but fixed, digital circuit $M$ operating in discrete time. A \textit{configuration} of $M$, denoted by $C$, is non-empty and finite set that represents a snapshot of $M$ at a discrete point in time. If the circuit $M$ has $m$ boolean signals, then its set of configurations is typically represented as a sequence $\mathbb{B}^{m}$, where $\mathbb{B} = \{ 0,1 \}$ is the set of boolean values.

\subsubsection{Circuit Model} A simple conceptual model of $M$ is a \textit{transition relation}, $M_{R} \subseteq C \times C$, where $(c,c') \in M_{R}$ means that $M$ can move from $c$ to $c'$ in one step\footnotemark. The power set of $C$, denoted by $\pow(C)$, can be viewed as a the set of \textit{predicates} on configurations, where $\cap$, $\cup$, and $\subseteq$ correspond to conjunction, disjunction and implication, respectively. We denote by $\cap Q$ and $\cup Q$ the intersection and union of all members of any $Q \subseteq \pow(C)$.

\footnotetext{\todo{Mention how this affects circuits with zero-delays?}}

$M_{R}$ induces a \textit{predicate transformer} $M_{F} \in \pow(C) \rightarrow \pow(C)$ using the relational image operation:

\begin{equation*}
M_{F}(p) = \{ c' \in C \mid \exists c \in p : (c,c') \in M_{R} \}
\end{equation*}

\noindent It is intuitively obvious that if $M$ is in one of the configurations in $p \in \pow(C)$, then in one time step it must be in one of the configurations in $M_{F}(p)$. We also see that $M_{F}$ distributes over arbitrary unions:

\begin{equation*}
M_{F}(\cup Q) = \cup \{ M_{F}(q) \mid q \in Q \}
\end{equation*}

\noindent for all $Q \subseteq \pow(C)$. In general, any $M_{F}$ that satisfies this distributive property also defines a $M_{R}$ through the equivalence $(c,c') \in M_{R} \iff c' \in M_{F}(\{ c \})$, that is to say, there is no loss of information going from $M_{R}$ to $M_{F}$ or vice versa. We adopt this functional model of $M$ and drop its subscript.

% It follows that $M_{F}$ preserves the empty set of constraints, i.e. $M_{F}(\emptyset) = \emptyset$, and is monotonic, i.e. $p \subseteq q \implies M_{F}(p) \subseteq M_{F}(q)$ for all $p, q \in \pow(C)$.

Exactly what $C$ and its signals are, is not important in this section. In practice, however, signals are typically divided into external, i.e. ``input'' and ``output'', and internal parts. While an input signal is generally controlled by the external environment, and thus unconstrained by $M$ itself, non-input signals are determined by the circuit topology and functionality. For example, supposed $M$ is the earlier example of a unit-delayed two-input AND gate, we could then define its model $M \in \pow(\mathbb{B}^{3}) \rightarrow \pow(\mathbb{B}^{3})$ as follows:

% although not required here

\begin{equation*}
M(p) = \{ \langle b_{1}, b_{2}, i_{1} \wedge i_{2} \rangle \in \mathbb{B}^{3} \mid \langle i_{1}, i_{2}, o \rangle \in p \}
\end{equation*}

\noindent Here $i_{1}$ and $i_{2}$ refer to the two inputs of the AND gate, $o$ the ignored output, and $b_{1}$ and $b_{2}$ are unconstrained inputs for the new configurations.

\subsubsection{Assertions and satisfaction} \label{sec:set-sat}

A \textit{trajectory assertion} for $M$ is quintuple $A = (S, s_{0}, R, \Antecedent, \Consequent)$, where $S$ is a finite set of \textit{states}, $s_{0} \in S$ is an \textit{initial state}, $R \subseteq S \times S$ is a \textit{transition relation}, $\Antecedent \in S \rightarrow \pow(C)$ and $\Consequent \in S \rightarrow \pow(C)$ label each state $s$ with an \textit{antecedent} $\Antecedent(s)$ and a \textit{consequent} $\Consequent(s)$. We assume that $(s,s_{0}) \notin S$ for all $s \in S$ without any loss of generality.

The circuit model $M$ intuitively \textit{satisfies} an assertion $A$ if, for every \textit{trajectory} $\tau$ through $M$ and every \textit{run} $\rho$ through $A$, $\tau$ satisfying the antecedents of $\rho$ entails that $\tau$ also satisfies the consequents of $\rho$. To be more specific, a \textit{trajectory} of $M$ is a non-empty sequences of configurations, $\tau \in C^{+}$, such that $\tau_{n} \in M(\{ \tau_{n-1} \})$ for all $n \in \mathbb{N} : 0 < n < | \tau |$. And a \textit{run} of $A$ is a non-empty sequence of states, $\rho \in S^{+}$, such that $\rho_{0} = s_{0}$ and $(\rho_{n-1}, \rho_{n}) \in R$ for all $n \in \mathbb{N} : 0 < n < | \rho |$. A $\tau$ satisfies the antecedents of $\rho$, denoted by $\tau \AntModels \rho$, iff $\tau_{n} \in \Antecedent(\rho_{n})$ for all $n \in \mathbb{N} : n < | \tau | = | \rho |$; satisfaction of consequents is defined similarly with $\Consequent$ and denoted by $\tau \ConModels \rho$.

That $M$ satisfies $A$, denoted by $M \models A$, can then formalized as follows: % \footnotemark

\begin{equation*}
\forall \tau \in \Traj(M) : \forall \rho \in \Runs(A) : | \tau | = | \rho | \implies (\tau \models_{a} \rho \implies \tau \models_{c} \rho)
\end{equation*}

\noindent where $\Traj(M)$ and $\Runs(A)$ denote the sets of all trajectories of $M$ and runs of $A$, respectively.

%% \footnotetext{\todo{This is equivalent to a DFA formulation~\cite{chou1999}.}}

%% For all functions $\Phi \in S \rightarrow \pow(C)$ and states $s \in S$, define $F \in S \rightarrow (\pow(C) \rightarrow \pow(C))$ as follows:

%% \begin{align}
%% F(s)(p) &= M(\Antecedent(s) \cap p) \\
%% \mathcal{F}(\Phi)(s) &= \Stmt{if } (s = s_{0}) \Stmt{ then } C \Stmt{ else } \cup \{ F(s')(\Phi(s')) \mid (s',s) \in R \}
%% \end{align}

%% \noindent $F$ preserves $\emptyset$, and both $F$ and $\mathcal{F}$ are montonic; two $\Phi, \Phi' \in S \rightarrow \pow(C)$ are ordered as $\Phi \subseteq \Phi' \iff \forall s \in S : \Phi(s) \subseteq \Phi'(s)$. Let $\Phi_{*} \in S \rightarrow \pow(C)$ be the least fixpoint of the equation $\Phi = \mathcal{F}(\Phi)$~\cite{davey2002}. Since both $S$ and $\pow(C)$ are finite, $\Phi_{*}$ is given by $\lim \, \Phi_{n}(s)$, where $\Phi_{n}$ is defined as follows:

%% \begin{equation}
%% \Phi_{n} = \Stmt{if } (n = 0) \Stmt{ then } (\lambda s \in S : \bot) \Stmt{ else } \mathcal{F}(\Phi_{n-1})
%% \end{equation}

%% $M$ \textit{satisfies} a trajectory assertion $A$, denoted by $M \smodels A$, iff $\forall s \in S : \Phi_{*}(s) \cap \Antecedent(s) \subseteq \Consequent(s)$.

\subsection{Lattice-theoretic STE}

Manipulating subsets of $\mathbb{B}^{m}$ is impractical for even moderately large $m$, which leads us to one of the key insights of STE. Namely, instead of manipulating subsets of $\mathbb{B}^{m}$ directly, one can use sequences of ternary values $\mathbb{T} = \mathbb{B} \cup \{ \X \} $ to approximate them, whose sizes are only linear in $m$. Here the $1$ and $0$ from $\mathbb{B}$ denotes specific, defined values whereas $\X$ denotes an ``unknown'' value that could be either $1$ or $0$. This intuition induces a partial order $\sqsubseteq$ on $\mathbb{T}$, where $0 \sqsubseteq \X$ and $1 \sqsubseteq \X$\footnotemark. For any $m \in \mathbb{N}$, this ordering on $\mathbb{T}$ is lifted component-wise to $\mathbb{T}^{m}$.

% As an example, we have that $\langle 1,1,0 \rangle$ and $\langle 1,0,0 \rangle$ are both $\sqsubseteq \langle 1,X,0 \rangle \in \mathbb{T}^{3}$ because they all agree on their first and third element and $X$ can be both $0$ and $1$.

\footnotetext{\todo{We use the reverse ordering of what is originally used in STE.}}

Note that $\mathbb{T}^{m}$ does not quite form a complete lattice because it lacks a bottom: both $0 \sqsubseteq \X$ and $1 \sqsubseteq \X$ but $0$ and $1$ are equally defined. A special bottom element $\bot$ is therefore introduced, such that $\bot \sqsubseteq t$ and $\bot \neq t$ for all $t \in \mathbb{T}^{m}$. The extended $\mathbb{T}_{\bot}^{m} = \mathbb{T}^{m} \cup \{ \bot \}$ then becomes a complete lattice. We denote the top element $\langle \X, \dots, \X \rangle$ of $\mathbb{T}_{\bot}^{m}$ by $\top$.

\subsubsection{Ternary lattices}

Generalising from any specific domain, let $(\hat P,\sqsubseteq)$ be a finite, complete lattice of \textit{abstract predicates} in which the meet $\meet$ and join $\join$ of any subset $Q \subseteq \hat P$ exists. Similar to the previous set operations for power sets, $\meet$, $\join$ and $\sqsubseteq$ correspond to conjunction, disjunction and implication for abstract predicates, respectively. Furthermore, for any $Q \subseteq \hat P$, we denote by $\meet Q$ and $\join Q$ the meet and join of all members of $Q$.

Let there be a Galois connection relating ``concrete'' predicates $\pow(C)$ and abstract predicates $\hat P$. The usual definition of a Galois connection is in terms of an \textit{abstraction} $\alpha \in \pow(C) \rightarrow \hat P$ and a \textit{concretisation} $\gamma \in \hat P \rightarrow \pow(C)$ function, such that $\alpha(p) \sqsubseteq \hat p \iff p \subseteq \gamma(\hat p)$ for all $p \in \pow(C)$ and $\hat p \in \hat P$. For example, a Galois connection from $\pow(\mathbb{B}^{m})$ to $\mathbb{T}_{\bot}^{m}$ for any $m \in \mathbb{N}$ can be defined in a natural way by its concretisation function $\gamma \in \mathbb{T}_{\bot}^{m} \rightarrow \pow(\mathbb{B}^{m})$:

\begin{align*}
\gamma ( \langle t_{0}, \dots,t_{m-1} \rangle ) &= \{ \langle b_{0}, \dots,b_{m-1} \rangle \in \mathbb{B}^{m} \mid \forall i < m : t_{i} \neq \X \Rightarrow b_{i} = t_{i} \} \\
\gamma ( \bot ) &= \emptyset
\end{align*}

\noindent Listing each concrete predicate approximated by a given abstract predicate. Its abstraction function $\alpha \in \pow(\mathbb{B}^{m}) \rightarrow \mathbb{T}_{\bot}^{m}$ instead finds the most precise abstract predicate for a set of concrete predicates:

\begin{align*}
\alpha ( p ) &= \join \{ \langle t_{0}, \ldots, t_{m-1} \rangle \in \mathbb{T}_{\bot}^{m} \mid \langle b_{0}, \ldots, b_{m-1} \rangle \in p, \forall i < m : b_{i} = t_{i} \} \\
\alpha ( \emptyset ) &= \bot
\end{align*}

% Listing each concrete predicate approximated by $\langle 1, \X, 0 \rangle$ with $\gamma$, we get the set $\{ \langle 1, 1, 0 \rangle,\allowbreak \langle 1, 0, 0 \rangle \}$ as desired.

% Abstracting the concrete predicates $\{ \langle 1, 1, 0 \rangle, \langle 1, 0, 0 \rangle \}$ with $\alpha$ indeed yields the original $\langle 1, \X, 0 \rangle$ abstraction.

\subsubsection{Abstract circuit model}

An \textit{abstract predicate transformer} $\hat M \in \hat P \rightarrow \hat P$ is an \textit{abstract interpretation}~\cite{cousot1996} of $M \in \pow(C) \rightarrow \pow(C)$ iff: $\hat M$ preserves $\bot$, i.e. $\hat M(\bot) = \bot$; $\hat M$ is monotonic, i.e. $\hat p \sqsubseteq \hat q \Rightarrow \hat M (\hat p) \sqsubseteq \hat M (\hat q)$ for all $\hat p, \hat q \in \hat P$; and $\alpha$, or $\gamma$, form a \textit{simulation relation} between $\pow(C)$ and $\hat P$, i.e. $\alpha(M(p)) \sqsubseteq \hat M(\alpha(p))$ for all $p \in \pow(C)$, or $M(\gamma(\hat p)) \subseteq \gamma(\hat M(\hat p))$ for all $\hat p \in \hat P$.

% \todo{and its Galois connection between $\pow(C)$ and $\hat P$ is a \textit{simulation relation}}

% and $\ll$ is a \textit{simulation relation} from $\pow(C)$ to $\hat P$, i.e. $p \ll \hat p \Rightarrow M (p) \ll \hat M (\hat p)$ for all $p \in \pow(C)$ and $\hat p \in \hat P$.

% That $\ll$ is a simulation relation can also be stated in terms of its abstraction $\alpha$ and concretisation $\gamma$ functions: $\alpha(M(p)) \sqsubseteq \hat M(\alpha(p))$ for all $p \in \pow(C)$, and $M(\gamma(\hat p)) \subseteq \gamma(\hat M(\hat p))$ for all $\hat p \in \hat P$.

Unlike its concrete model, $\hat M$ does not distribute over arbitrary join because information is potentially discarded by the ternary logic durin a join. As an example, let the following $\hat M$ abstract the earlier unit-delayed AND gate:

% ..., that would have been kept by union in the original model $M$

\begin{equation*}
\begin{array}{llll}
  \hat M(\langle 1, 1, p_{2} \rangle) & = \langle \X, \X, 1 \rangle \qquad & \hat M(\langle 0, 0, p_{2} \rangle) & = \langle \X, \X, 0 \rangle \\
  \hat M(\langle 0, \X, p_{2} \rangle) & = \langle \X, \X, 0 \rangle & \hat M(\langle \X, 0, p_{2} \rangle) & = \langle \X, \X, \X \rangle \\
  \hat M(\langle p_{0}, p_{1}, p_{2} \rangle) & = \langle \X, \X, \X \rangle & &
\end{array}
\end{equation*}

% Note: Can we shorten the def. of funny M somehow? Or use a simpler gate.

\noindent where the last, most general matching is overlapped by the more concrete ones. If we apply $\hat M$ to the join of $\langle 0, 1, \X \rangle$ and $\langle 1, 0, \X \rangle$, or if we apply $\hat M$ to them individually and then join, we get two different results:

\begin{equation*}
\begin{array}{lll}
  \hat M(\langle 0, 1, \X \rangle \join \langle 1, 0, \X \rangle) &= \hat M(\langle \X, \X, \X \rangle) &= \langle \X, \X, \X \rangle \\
  \hat M(\langle 0, 1, \X \rangle) \join \hat M(\langle 1, 0, \X \rangle) &= \langle \X, \X, 0 \rangle \join \langle \X, \X, 0 \rangle &= \langle \X, \X, 0 \rangle
\end{array}
\end{equation*}

\noindent The inequality $\join \{ \hat M(\hat q) \mid \hat q \in \hat Q \} \sqsubseteq \hat M(\join \hat Q)$ for all $\hat Q \sqsubseteq \hat P$ does however hold, since it is implied by the monotonicity of $\hat M$.

\subsubsection{Assertions and satisfaction}

A trajectory assertion for an abstract model $\hat M$ is a quintuple $\hat A = (S, s_{0}, R, \hat{\pi}_{a}, \hat{\pi}_{c})$, where $S$, $s_{0}$, and $R$ are as in section~\ref{sec:set-sat} and $\hat{\pi}_{a} \in S \rightarrow \hat P$ and $\hat{\pi}_{c} \in S \rightarrow \hat P$ label each state $s$ with an abstract predicate for its antecedent and consequent, respectively.

\todo{Here follows the definition in~\cite{chou1999}.} For all functions $\hat \Phi \in S \rightarrow \hat P$ and states $s \in S$, define $\hat F \in S \rightarrow (\hat P \rightarrow \hat P)$ and $\hat{\mathcal{F}} \in (S \rightarrow \hat P) \rightarrow (S \rightarrow \hat P)$ as follows:

\begin{align}
\hat F(s)(\hat p) &= \hat M(\Antecedent(s) \meet \hat p) \\
\hat{\mathcal{F}}(\Phi)(s) &= \Stmt{if } (s = s_{0}) \Stmt{ then } \top \Stmt{ else } \join \{ \hat F(s')(\Phi(s')) \mid (s',s) \in R \}
\end{align}

\noindent $\hat F$ preserves $\bot$, and both $\hat F$ and $\hat{\mathcal{F}}$ are monotonic; two $\hat \Phi, \hat \Phi' \in S \rightarrow \hat P$ are ordered as $\hat \Phi \sqsubseteq \hat \Phi' \iff \forall s \in S : \hat \Phi(s) \sqsubseteq \hat \Phi'(s)$. Let $\hat \Phi_{*} \in S \rightarrow \hat P$ be the least fixpoint of the equation $\hat \Phi = \hat{\mathcal{F}}(\hat \Phi)$~\cite{davey2002}. Since both $S$ and $\hat P$ are finite, $\hat \Phi_{*}$ is given by $\lim \, \hat \Phi_{n}(s)$, where $\hat \Phi_{n}$ is defined as follows:

\begin{equation}
\hat \Phi_{n} = \Stmt{if } (n = 0) \Stmt{ then } (\lambda s \in S : \bot) \Stmt{ else } \hat{\mathcal{F}}(\hat \Phi_{n-1})
\end{equation}

$\hat M$ \textit{satisfies} a trajectory assertion\footnotemark $\hat A$, denoted by $\hat M \LatModels \hat A$, iff $\hat \Phi_{*}(s) \meet \pi_{\alpha}(s) \sqsubseteq \Consequent(s)$ for all $s \in S$.

% That is, $\hat M$ satisfies $\hat A$ if, for every state $s$ in the assertion, the information gathered from $\hat M$ through the consequent in every path to $s$ implies the antecedent for $s$.

\footnotetext{That $\hat M$ satisfies $\hat A$ implies that a concretisation of $\hat A$ can also be satisfied by the original, set-based model $M$ \cite{chou1999}.}
