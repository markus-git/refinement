\section{System refinement}

Consider another fixed, but arbitrary, circuit model $N \in \mathcal{P}(C') \rightarrow \mathcal{P}(C')$ and let $\hat N \in \hat Q \rightarrow \hat Q$ be an abstract interpretation of it; $\hat Q$ is an abstract predicate with a Galois connection to $\mathcal{P}(C')$. In the previous sections, exactly what abstract predicates like $\hat Q$ are, were not important. In order to reason about refinement, however, we need to make a distinction between their \textit{external} and \textit{internal} elements of $\hat P$ and $\hat Q$. Specifically, we will argue that $\hat M$ \textit{refines} $\hat N$ if every \textit{visible behaviour} of $\hat M$ can be matched by $\hat N$ while assuming nothing about initial configurations.

\subsection{Refinement through visible simulation}

%% \subsubsection{Externally visible elements}

Let the output of an abstract predicate $\hat P$ be identified by the idempotent mapping $\Out \in \hat P \rightarrow \hat P$, such that $\Out(\cdot)$ is monotonic, i.e. $\hat p \sqsubseteq \hat q \implies \Out(\hat p) \sqsubseteq \Out(\hat q)$; and the greatest bound for an output, i.e. $\Out(\hat p) \sqsubseteq \Out(\hat q) \iff \hat p \sqsubseteq \Out(\hat q)$. In a similar vein, let the inputs of an abstract predicate $\hat P$ be identified by another mapping, $\In \in \hat P \rightarrow \hat P$. The sets of all possible inputs and outputs for $\hat P$ are defined as $\In(\hat P) = \{ \In(\hat p) \mid \hat p \in \hat P \}$ and $\Out(\hat P) = \{ \Out(\hat p) \mid \hat p \in \hat P \}$. With a slight abuse of notation, we overload $\Out(\cdot)$ to accept predicates from $\hat Q$.

In the case of an unit-delayed AND gate and its predicates $\langle p_{0}, p_{1}, p_{2} \rangle \in \mathbb{T}_{\bot}^{3}$, for example, $\In(\cdot)$ and $\Out(\cdot)$ can be defined as projections which maps each non-input and non-output element to $\X$, respectively:

%% ... is idempotent, i.e. $\Out(\Out(\hat p)) = \Out(\hat p)$;

%% ... which identify the ``inputs'' and ``outputs'' of $\hat P$, respectively.

\begin{equation*}
\begin{aligned}[t]
\In(\langle \hat p_{0}, \hat p_{1}, \hat p_{2} \rangle) &= \langle \hat p_{0}, \hat p_{1}, \X \rangle \\
\In(\bot) &= \bot
\end{aligned}
\qquad
\begin{aligned}[t]
\Out(\langle \hat p_{0}, \hat p_{1}, \hat p_{2} \rangle) &= \langle \X, \X, p_{2} \rangle \\
\Out(\bot) &= \bot
\end{aligned}
\end{equation*}

\noindent It is easy to see that $\Out(\cdot)$ is monotonic, and that it produces the greatest bound for any $\mathbb{T}^{3}$ with an output $\sqsubseteq \hat p_{2}$.

\todo{The response of $\hat M$ in state $\hat p$ to an input $\hat \iota \in \In(\hat P)$ is determined by $\hat M(\hat \iota \sqcap \hat p)$}. \todo{Intuitively, if the output of $\hat M$ and $\hat N$ is ordered in each possible state reached by a sequence of inputs when starting from $\top$, then $\hat M$ visually refines $\hat N$. Their internal states could differ at times, but externally they behave the same}.

%% ToDo: Badly written.

\subsubsection{Visible simulation as a Galois connection}

Let $\cc \, \subseteq \hat P \times \hat Q$ be a Galois connection, where $\hat p \cc \hat q$ reads as ``$\hat p$ refines $\hat q$'', such that:

\begin{equation*}
\forall \hat p \in \hat P^{*} : \forall \hat q \in \hat Q^{*} : \hat p \cc \hat q \iff \sqcup \hat P^{*} \cc \sqcap \hat Q^{*}
\end{equation*}

\noindent for all subsets $\hat P^{*} \subseteq \hat P$ and $\hat Q^{*} \subseteq \hat Q$. The usual abstraction $\alpha \in \hat P \rightarrow \hat Q$ and concretisation $\gamma \in \hat Q \rightarrow \hat P$ functions are derived from $\cc$ as follows:

\begin{align*}
\alpha(p) = \sqcap \{ \hat p \in \hat P \mid \hat q \cc \hat p \} && \gamma(\hat p) = \sqcup \{ \hat q \in \hat Q \mid \hat q \cc \hat p \}
\end{align*}

\noindent We note that $\gamma$ is monotone, preserves top and distributes over arbitrary meet, i.e. $\gamma(\sqcap \hat Q) = \sqcap \{ \gamma(\hat q) \in \hat P \mid \hat q \in \hat Q\}$. Similarly, $\alpha$ is monotone, preserves bottom and distributes over arbitrary join.

Like the earlier Galois connection, the relation $\cc$ can also be thought of as an extension of the orderings inside $\hat P$ and $\hat Q$ to an ordering between them. A relation $\cc \, \subseteq \hat P \times \hat Q$ is a \textit{visible simulation relation} between $\hat M$ and $\hat N$ iff the top of $\hat P$ refines the top of $\hat Q$, i.e. $(\top \in \hat P) \cc \, (\top \in \hat Q)$, and $\hat p \cc \hat q$ implies (1) $\Out(\hat p) \sqsubseteq \gamma(\Out(\hat q))$ and (2) $\hat M(\hat \iota \sqcap \hat p) \cc \hat N(\alpha(\hat \iota) \sqcap \hat q)$ for all inputs $\hat \iota \in \In(\hat P)$.

%% Let the binary relation $\cc$ be a simulation between the visible parts of $\hat P$ and $\hat Q$, such that $\hat p \cc \hat q$ implies (1) $\Out(\hat p) \sqsubseteq \gamma(\Out(\hat q))$ and (2) $\hat M(\hat \iota \sqcap \hat p) \cc \hat N(\alpha(\hat \iota) \sqcap \hat q)$ for all inputs $\hat \iota \in \In(\hat P)$. We extend this simulation relation to abstract model transformers, and say that $\hat M$ refines $\hat N$, denoted $\hat M \cc \hat N$, if the top element of $\hat P$ refines the top element of $\hat Q$, i.e. $(\top \in \hat P) \cc \, (\top \in \hat Q)$.

\todo{Because $\top$ represents every possible state in its predicate type, that $\hat M \cc \hat N$ thus implies that every state in $\hat M$ is simulated by every state in $\hat N$}. \todo{However, using $\top$ also means we simply demand that their outputs are ordered, since both will output X until the inputs have flushed trough them}.

\subsubsection{External trajectory assertions and satisfaction}

Recall that a trajectory assertion for $\hat N$ is a quintuple $\hat A = (S, s_{0}, R, \pi_{a}, \pi_{c})$, where $\pi_{a} \in S \rightarrow \hat Q$ and $\pi_{c} \in S \rightarrow \hat Q$ label each state $s \in S$ with an antecedent $\pi_{a}(s)$ and a consequent $\pi_{c}(s)$. If these antecedents only mention inputs, i.e. $\pi_{a} \in S \rightarrow \In(\hat P)$, and consequents only mention outputs, i.e. $\pi_{c} \in S \rightarrow \Out(\hat P)$, then $\hat A$ is referred to as a \textit{visible trajectory assertion} for $\hat N$, which we denote by $\hat A_{vis}$. Define $\alpha(\hat A) = (S, s_{0}, R, \alpha(\pi_{a}), \alpha(\pi_{c}))$, where $\alpha(\pi_{a}) = \lambda s \in S : \alpha(\pi_{a}(s))$ and $\alpha(\pi_{a}) = \lambda s \in S : \alpha(\pi_{a}(s))$. Note that, if $\hat A_{vis}$ is an assertion for $\hat N$, then $\alpha(\hat A_{vis})$ is an assertion for $\hat M$.

%% \todo{That is, $\alpha(\hat A)$ is a trajectory assertion for $\hat M$}.

%% A satisfied external trajectory assertion is property of $N$ that must hold regardless of its internal state.}

\begin{theorem}
\label{thm:refinement}
If $\hat M$ and $\hat N$ are abstract predicate transformers such that $\hat M \cc \hat N$, and $\hat A_{vis}$ is a visible trajectory assertion for $\hat N$, then:

\begin{equation*}
\hat N \models \hat A_{vis} \implies \hat M \models \alpha(\hat A_{vis})
\end{equation*}
\end{theorem}

A common use of refinement is safe substitution of sub-circuits in a larger system, as refinement between the swapped components implies that any assertions satisfied by the original system would also be satisfied by the new one. We define the abstract interpretation of such composite systems as the product of its individual interpretations $\hat M_{c} \subseteq \hat M_{1} \times \ldots \times \hat M_{n}$.

\begin{theorem}
\label{thm:refinement-product}
If $\hat N_{1} \times \hat N_{2}$ and $\hat M$ are abstract predicate transformer such that $\hat M \cc \hat N_{1}$, and $\hat A$ is a trajectory assertion for $\hat N$, then:

\begin{equation*}
\hat N_{1} \times \hat N_{2} \models \hat A \implies \hat M \times \hat N_{2} \models \hat A
\end{equation*}
\end{theorem}

% LocalWords:  consequents

%% A \textit{driver} $\delta \in \hat P^{+}$ for $\hat M$ is a nonempty sequence of abstract predicates $\langle \hat \iota_{0}, \ldots \rangle$ such that $\hat \iota_{i} = \In(\hat \iota_{i})$ for all $i \in \mathcal{N} : i < | \delta |$. Every driver $\delta$ induces a \textit{trajectory} $\langle \tau_{0}, \ldots, \tau_{| \delta | + 1} \rangle \in \hat P^{+}$ in $\hat M$, where $\tau_{0} = \top$ and $\tau_{i+1} = \hat N(\hat \iota_{i} \sqcap \tau_{i})$ for all $i \in \mathbb{N} : i < | \delta |$; the trajectory induced in $\hat M$ by a driver $\delta$ is denoted by $\Driv{\hat N}{\delta}$.

%% \begin{equation*}
%% \forall \delta \in \hat P^{+} : \Out(\Driv{\hat M}{\delta}) \sqsubseteq \gamma(\Out(\Driv{\hat N}{\alpha(\delta)}))
%% \end{equation*}
