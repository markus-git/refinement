\section{System refinement}

Consider another fixed, but arbitrary, circuit model $N \in \mathcal{P}(C') \rightarrow \mathcal{P}(C')$ and let $\hat N \in \hat Q \rightarrow \hat Q$ be an abstract interpretation of it; $\hat Q$ is an abstract predicate with a Galois connection to $\mathcal{P}(C')$. In the previous sections, exactly what abstract predicates like $\hat Q$ are, were not important. In order to reason about refinement, however, we need to make a distinction between their \textit{visible} and internal elements. Specifically, \todo{we wish to say that} $\hat M$ refines $\hat N$ if every visible behaviour of $\hat M$ is allowed by $\hat N$ while assuming nothing about initial configurations.

Let the visible elements of an abstract predicate $\hat P$ be those given by two monotone and idempotent mappings, $\In \in \hat P \rightarrow \hat P$ and $\Out \in \hat P \rightarrow \hat P$, which identify the ``inputs'' and ``outputs'' of $\hat P$, respectively. Further, let $\In(\cdot)$ and $\Out(\cdot)$ identify the most general state that satisfy their constraints: $\In(\hat p) \sqsubseteq \In(\hat p') \implies \hat p \sqsubseteq \In(\hat p')$ and $\Out(\hat p) \sqsubseteq \Out(\hat p') \implies \hat p \sqsubseteq \Out(\hat p')$ for all $\hat p, \hat p' \in \hat P$. An \textit{input} of $\hat P$ is thus the greatest predicate $\hat \iota \in \hat P = \In(\hat \iota)$ for some input constraints; the set of all possible inputs is defined as $\In(\hat P) = \{ \In(\hat p) \mid \hat p \in \hat P \}$. In the case of $\mathbb{T}_{\bot}^{3}$, for example, $\In(\cdot)$ and $\Out(\cdot)$ could be defined as:

%% Similarly, an \textit{output} is the greatest $\hat \omicron \in \hat P$ for some output constraints.

\begin{equation*}
\begin{aligned}[t]
\In(\langle \hat p_{0}, \hat p_{1}, \hat p_{2} \rangle) &= \langle \hat p_{0}, \hat p_{1}, \X \rangle \\
\In(\bot) &= \bot
\end{aligned}
\qquad
\begin{aligned}[t]
\Out(\langle \hat p_{0}, \hat p_{1}, \hat p_{2} \rangle) &= \langle \X, \X, p_{2} \rangle \\
\Out(\bot) &= \bot
\end{aligned}
\end{equation*}

%% All visible elements of a predicate is identified thus: $\Vis(\hat p) = \In(\hat p) \sqcap \Out(\hat p)$.

%% The response of $\hat M$ in state $\hat p$ to an input $\hat \iota$ is given by $\hat M(\hat \iota \sqcap \hat p)$.

\noindent With a slight abuse of notation, we overload both $\In(\cdot)$ and $\Out(\cdot)$ to accept predicates from $\hat Q$.

Let $\cc \, \subseteq \hat P \times \hat Q$, where $\hat p \cc \hat q$ reads as ``$\hat p$ refines $\hat q$'', be a Galois connection such that for all $\hat P' \subseteq \hat P$ and $\hat Q' \subseteq \hat Q$:

\begin{equation*}
\forall \hat p \in \hat P' : \forall \hat q \in \hat Q' : \hat p \cc \hat q \iff \sqcup \hat P' \cc \sqcap \hat Q'
\end{equation*}

\noindent Like the earlier Galois connection, $\cc$ can intuitively be thought of as an extension of the orderings inside $\hat P$ and $\hat Q$ to an ordering between them. The abstraction and concretisation functions, $\alpha \in \hat P \rightarrow \hat Q$ and $\gamma \in \hat Q \rightarrow \hat P$, can also be derived from $\cc$ as before: $\alpha(p) = \sqcap \{ \hat p \in \hat P \mid \hat q \cc \hat p \}$ and $\gamma(\hat p) = \sqcup \{ \hat q \in \hat Q \mid \hat q \cc \hat p \}$. We note that $\gamma$ is monotone, preserves top and distributes over arbitrary meet, i.e. $\gamma(\sqcap \hat Q) = \sqcap \{ \gamma(\hat q) \in \hat P \mid \hat q \in \hat Q\}$. Similarly, $\alpha$ is monotone, preserves bottom and distributes over arbitrary join.

Let the binary relation $\cc$ be a simulation between the visible parts of $\hat P$ and $\hat Q$, such that $\hat p \cc \hat q$ implies (1) $\Out(\hat p) \sqsubseteq \gamma(\Out(\hat q))$ and (2) $\hat M(\hat \iota \sqcap \hat p) \cc \hat N(\alpha(\hat \iota) \sqcap \hat q)$ for all inputs $\hat \iota \in \In(\hat P)$. We extend this simulation relation to abstract model transformers, and say that $\hat M$ refines $\hat N$, denoted $\hat M \cc \hat N$, if the top element of $\hat P$ refines the top element of $\hat Q$, i.e. $(\top \in \hat P) \cc \, (\top \in \hat Q)$. \todo{Intuitively, if $\hat M$ refines $\hat N$, then every visible behaviour of $\hat M$ has a corresponding behaviour in $\hat N$ that \ldots}

%% Because $\top$ represents every possible state in its predicate type, that $\hat M \cc \hat N$ thus implies that every state in $\hat M$ is simulated by every state in $\hat N$. However, using $\top$ also means we simply demand that their outputs are ordered, since both will output X until the inputs have flushed trough them.}

A trajectory assertion $\hat A = (S, s_{0}, R, \pi_{a}, \pi_{c})$ for $\hat N$ where antecedents only mention inputs, $\pi_{a} \in S \rightarrow \In(\hat P)$, and consequents only mention outputs, $\pi_{c} \in S \rightarrow \Out(\hat P)$, is referred to as a \textit{visible trajectory assertion} and denoted by $\hat A_{vis}$. Define $\alpha(\hat A) = (S, s_{0}, R, \alpha(\pi_{a}), \alpha(\pi_{c}))$, where $\alpha(\pi_{a}) = \lambda s \in S : \alpha(\pi_{a}(s))$ and $\alpha(\pi_{a}) = \lambda s \in S : \alpha(\pi_{a}(s))$.

%% \todo{That is, $\alpha(\hat A)$ is a trajectory assertion for $\hat M$}.

%% A satisfied external trajectory assertion is property of $N$ that must hold regardless of its internal state.}

\begin{theorem}
\label{thm:refinement}
If $\hat M$ and $\hat N$ are abstract predicate transformers such that $\hat M \cc \hat N$, and $\hat A_{vis}$ is a trajectory assertion restricted to visible elements of $\hat N$, then:

\begin{equation*}
\hat N \models \hat A_{vis} \implies \hat M \models \alpha(\hat A_{vis})
\end{equation*}
\end{theorem}

\begin{corollary}
\label{thm:refinement-product}
If $\hat N = \hat N_{1} \times \hat N_{2}$ is an abstract predicate transformer defined as the product of two transformers $\hat N_{1}$ and $\hat N_{2}$, and $\hat M$ is another transformer such that $\hat M \cc \hat N_{0}$, then for any trajectory assertion $\hat A_{vis}$ restricted to visible elements of $\hat N$ we must have that:

\begin{equation*}
\hat N_{1} \times \hat N_{2} \models \hat A_{vis} \implies \hat M \times \hat N_{2} \models \hat A_{vis}
\end{equation*}
\end{corollary}

% LocalWords:  consequents

%% A \textit{driver} $\delta \in \hat P^{+}$ for $\hat M$ is a nonempty sequence of abstract predicates $\langle \hat \iota_{0}, \ldots \rangle$ such that $\hat \iota_{i} = \In(\hat \iota_{i})$ for all $i \in \mathcal{N} : i < | \delta |$. Every driver $\delta$ induces a \textit{trajectory} $\langle \tau_{0}, \ldots, \tau_{| \delta | + 1} \rangle \in \hat P^{+}$ in $\hat M$, where $\tau_{0} = \top$ and $\tau_{i+1} = \hat N(\hat \iota_{i} \sqcap \tau_{i})$ for all $i \in \mathbb{N} : i < | \delta |$; the trajectory induced in $\hat M$ by a driver $\delta$ is denoted by $\Driv{\hat N}{\delta}$.

%% \begin{equation*}
%% \forall \delta \in \hat P^{+} : \Out(\Driv{\hat M}{\delta}) \sqsubseteq \gamma(\Out(\Driv{\hat N}{\alpha(\delta)}))
%% \end{equation*}
