\section{System refinement}

Consider another fixed, but arbitrary, circuit model $N \in \mathcal{P}(C') \rightarrow \mathcal{P}(C')$ and let $\hat N \in \hat Q \rightarrow \hat Q$ be an abstract interpretation of it; $\hat Q$ is an abstract predicate with a Galois connection to $\mathcal{P}(C')$. In the previous sections, exactly what abstract predicates like $\hat Q$ are, were not important. In order to reason about refinement, however, we need to make a distinction between their \textit{external} and \textit{internal} elements of $\hat P$ and $\hat Q$. Specifically, we will argue that $\hat M$ \textit{refines} $\hat N$ if every visible behaviour of $\hat M$ can be matched by $\hat N$ while assuming nothing about initial configurations.

\subsection{Visible simulation as refinement}

Let the visible output of an abstract predicate $\hat P$ be identified by the mapping $\Out \in \hat P \rightarrow \hat P$, such that $\Out(\cdot)$ is monotonic, i.e. $\hat p \sqsubseteq \hat q \implies \Out(\hat p) \sqsubseteq \Out(\hat q)$; and produces the greatest bound for an output, i.e. $\Out(\hat p) \sqsubseteq \Out(\hat q) \iff \hat p \sqsubseteq \Out(\hat q)$. In the case of $\mathbb{T}_{\bot}^{3}$, for example, $\Out(\cdot)$ can be defined naturally as a projection which maps each non-output element to $\X$:

%% ... is idempotent, i.e. $\Out(\Out(\hat p)) = \Out(\hat p)$;

%% ... which identify the ``inputs'' and ``outputs'' of $\hat P$, respectively.

\begin{align*}
\Out(\langle \hat p_{0}, \hat p_{1}, \hat p_{2} \rangle) = \langle \X, \X, p_{2} \rangle && \Out(\bot) = \bot
\end{align*}

\noindent It is easy to see that this definition is idempotent and monotonic, and that it produces the greatest bound for any $\mathbb{T}^{3}$ with an output $\sqsubseteq \hat p_{2}$. With a slight abuse of notation, we overload $\Out(\cdot)$ to accept predicates from $\hat Q$.

%% An \textit{input} and \textit{output} of $\hat P$ are thus predicates $\hat \iota, \hat \omicron \in \hat P$ such that $\hat \iota = \In(\hat \iota)$ and $\hat \omicron = \Out(\hat \omicron)$; the set of all possible inputs is defined as $\In(\hat P) = \{ \In(\hat p) \mid \hat p \in \hat P \}$.

%% The response of $\hat M$ in state $\hat p$ to an input $\hat \iota$ is given by $\hat M(\hat \iota \sqcap \hat p)$.

%% \begin{equation*}
%% \begin{aligned}[t]
%% \In(\langle \hat p_{0}, \hat p_{1}, \hat p_{2} \rangle) &= \langle \hat p_{0}, \hat p_{1}, \X \rangle \\
%% \In(\bot) &= \bot
%% \end{aligned}
%% \qquad
%% \begin{aligned}[t]
%% \Out(\langle \hat p_{0}, \hat p_{1}, \hat p_{2} \rangle) &= \langle \X, \X, p_{2} \rangle \\
%% \Out(\bot) &= \bot
%% \end{aligned}
%% \end{equation*}

Let $\cc \, \subseteq \hat P \times \hat Q$, where $\hat p \cc \hat q$ reads as ``$\hat p$ refines $\hat q$'', be a Galois connection such that for all $\hat P' \subseteq \hat P$ and $\hat Q' \subseteq \hat Q$:

\begin{equation*}
\forall \hat p \in \hat P' : \forall \hat q \in \hat Q' : \hat p \cc \hat q \iff \sqcup \hat P' \cc \sqcap \hat Q'
\end{equation*}

\noindent Like the earlier Galois connection, $\cc$ can intuitively be thought of as an extension of the orderings inside $\hat P$ and $\hat Q$ to an ordering between them. The abstraction and concretisation functions, $\alpha \in \hat P \rightarrow \hat Q$ and $\gamma \in \hat Q \rightarrow \hat P$, can also be derived from $\cc$ as before: $\alpha(p) = \sqcap \{ \hat p \in \hat P \mid \hat q \cc \hat p \}$ and $\gamma(\hat p) = \sqcup \{ \hat q \in \hat Q \mid \hat q \cc \hat p \}$. We note that $\gamma$ is monotone, preserves top and distributes over arbitrary meet, i.e. $\gamma(\sqcap \hat Q) = \sqcap \{ \gamma(\hat q) \in \hat P \mid \hat q \in \hat Q\}$. Similarly, $\alpha$ is monotone, preserves bottom and distributes over arbitrary join.

Let the binary relation $\cc$ be a simulation between the visible parts of $\hat P$ and $\hat Q$, such that $\hat p \cc \hat q$ implies (1) $\Out(\hat p) \sqsubseteq \gamma(\Out(\hat q))$ and (2) $\hat M(\hat \iota \sqcap \hat p) \cc \hat N(\alpha(\hat \iota) \sqcap \hat q)$ for all inputs $\hat \iota \in \In(\hat P)$. We extend this simulation relation to abstract model transformers, and say that $\hat M$ refines $\hat N$, denoted $\hat M \cc \hat N$, if the top element of $\hat P$ refines the top element of $\hat Q$, i.e. $(\top \in \hat P) \cc \, (\top \in \hat Q)$. \todo{Intuitively, if $\hat M$ refines $\hat N$, then every visible behaviour of $\hat M$ has a corresponding behaviour in $\hat N$ that \ldots}

%% Because $\top$ represents every possible state in its predicate type, that $\hat M \cc \hat N$ thus implies that every state in $\hat M$ is simulated by every state in $\hat N$. However, using $\top$ also means we simply demand that their outputs are ordered, since both will output X until the inputs have flushed trough them.}

A trajectory assertion $\hat A = (S, s_{0}, R, \pi_{a}, \pi_{c})$ for $\hat N$ where antecedents only mention inputs, $\pi_{a} \in S \rightarrow \In(\hat P)$, and consequents only mention outputs, $\pi_{c} \in S \rightarrow \Out(\hat P)$, is referred to as a \textit{visible trajectory assertion} and denoted by $\hat A_{vis}$. Define $\alpha(\hat A) = (S, s_{0}, R, \alpha(\pi_{a}), \alpha(\pi_{c}))$, where $\alpha(\pi_{a}) = \lambda s \in S : \alpha(\pi_{a}(s))$ and $\alpha(\pi_{a}) = \lambda s \in S : \alpha(\pi_{a}(s))$.

%% \todo{That is, $\alpha(\hat A)$ is a trajectory assertion for $\hat M$}.

%% A satisfied external trajectory assertion is property of $N$ that must hold regardless of its internal state.}

\begin{theorem}
\label{thm:refinement}
If $\hat M$ and $\hat N$ are abstract predicate transformers such that $\hat M \cc \hat N$, and $\hat A_{vis}$ is a trajectory assertion restricted to visible elements of $\hat N$, then:

\begin{equation*}
\hat N \models \hat A_{vis} \implies \hat M \models \alpha(\hat A_{vis})
\end{equation*}
\end{theorem}

\begin{corollary}
\label{thm:refinement-product}
If $\hat N = \hat N_{1} \times \hat N_{2}$ is an abstract predicate transformer defined as the product of two transformers $\hat N_{1}$ and $\hat N_{2}$, and $\hat M$ is another transformer such that $\hat M \cc \hat N_{0}$, then for any trajectory assertion $\hat A_{vis}$ restricted to visible elements of $\hat N$ we must have that:

\begin{equation*}
\hat N_{1} \times \hat N_{2} \models \hat A_{vis} \implies \hat M \times \hat N_{2} \models \hat A_{vis}
\end{equation*}
\end{corollary}

% LocalWords:  consequents

%% A \textit{driver} $\delta \in \hat P^{+}$ for $\hat M$ is a nonempty sequence of abstract predicates $\langle \hat \iota_{0}, \ldots \rangle$ such that $\hat \iota_{i} = \In(\hat \iota_{i})$ for all $i \in \mathcal{N} : i < | \delta |$. Every driver $\delta$ induces a \textit{trajectory} $\langle \tau_{0}, \ldots, \tau_{| \delta | + 1} \rangle \in \hat P^{+}$ in $\hat M$, where $\tau_{0} = \top$ and $\tau_{i+1} = \hat N(\hat \iota_{i} \sqcap \tau_{i})$ for all $i \in \mathbb{N} : i < | \delta |$; the trajectory induced in $\hat M$ by a driver $\delta$ is denoted by $\Driv{\hat N}{\delta}$.

%% \begin{equation*}
%% \forall \delta \in \hat P^{+} : \Out(\Driv{\hat M}{\delta}) \sqsubseteq \gamma(\Out(\Driv{\hat N}{\alpha(\delta)}))
%% \end{equation*}
