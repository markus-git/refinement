\section{System refinement}

Consider another fixed, but arbitrary, circuit model $N \in \mathcal{P}(C_{q}) \rightarrow \mathcal{P}(C_{q})$. Let the abstract predicate transformer $\hat N \in \hat Q \rightarrow \hat Q$ be an abstract interpretation of $N$, where $(\hat Q, \sqsubseteq_{q})$ forms a finite, complete lattice such that there is a Galois connection $\ll_{q} \: \in \left. \subseteq \mathcal{P}(C_{q}) \times \hat Q \right.$. In the previous sections, exactly what abstract predicates like $\hat Q$ are, were not important. In order to reason about refinement, however, we need to make a distinction between the \textit{externally visible} and internal elements of an abstract predicate.

% we then we say that $\hat M$ \textit{refines} $\hat N$ if every \textit{externally visible behaviour} allowed by $\hat M$ is also allowed by $\hat N$, regardless of any initial configurations.

% \todo{Example?}

Specifically, let the \textit{externally visible} parts of an abstract predicate $\hat Q$ be the subsets given by two projections, $\InProj$ and $\OutProj$, identifying the ``inputs'' and ``outputs'' of $\hat Q$, respectively. Further, let $\out{\cdot} \in \hat Q \rightarrow \OutProj(\hat Q) = \hat O$ be a mapping that takes each $\hat q \in \hat Q$ to its visible outputs $\out{\hat Q} \in \hat O$. We extend $\out{\cdot}$ to sequences component-wise and, with a slight abuse of notation, overload both projections and the mapping to accept predicates from $\hat P$.

Let there be an order isomorphism $\cc \: \in \left. \subseteq \hat P \times \hat Q \right.$.

\todo{Order isomorphism over $\hat Q$ and $\hat P$.}

% Further, in order to compare inputs and outputs, we assume that $\InProj(\hat P) = \InProj(\hat Q) = \hat I$ and $\OutProj(\hat P) = \OutProj(\hat Q) = \hat O$.

A \textit{driver} of $\hat M$ and $\hat N$ is a nonempty sequence of inputs, $\delta \in \hat I^{+}$, and induces a trajectory $\tau$ in $\hat M$ (resp. $\hat N$) where $\tau[0] = \top$ and $\forall i \in \mathbb{N} : i < | \delta | \implies \tau[i+1] = \hat M(\delta[i] \sqcap \tau[i])$; the trajectory induced by a driver $\delta$ in $\hat M$ is denoted by $\Driv{\hat M}{\delta}$. Intuitively, if $\hat M$ produces the same, or at least more specified, outputs than $\hat N$ for all possible drivers, then every visible behaviour of $\hat M$ is covered by $\hat N$. We thus say that $\hat M$ refines $\hat N$, denoted by $\hat M \leq \hat N$, iff:

\todo{Footnote that ``Traj'' comes from trajectories in prev. papers?}

\todo{We have to use $=$ for our trajectories since $\sqsubseteq$ allows one to pick bad states for unconstrained wires.}

\begin{equation*}
\forall \delta \in \hat I^{+} : \out{\Driv{\hat M}{\delta}} \sqsubseteq \out{\Driv{\hat N}{\delta}}
\end{equation*}

\todo{Example!}

\subsubsection{Simulation} Let $\enc \in \hat P \times \hat Q$ be a simulation relation such that $\hat p \enc \hat q$ implies (1) $\out{\hat p} \sqsubseteq \out{\hat q}$ and (2) $\hat M(\hat \iota \sqcap \hat p) \enc \hat N(\hat \iota \sqcap \hat q)$ for all inputs $\hat \iota \in \hat I$. We extend this relation to $\hat M$ and $\hat N$ such that $\hat M \enc \hat N$ iff their top elements are related, $(\top \in \hat P) \enc \, (\top \in \hat Q)$.

\todo{This relation is equivalent to the earlier notion of refinement: $\hat M \leq \hat N \iff \hat M \enc \hat N$.}

\todo{We can have trajectories defined by the simulation relation as well.}

% (read as $\hat p$ ``encodes'' $\hat q$)

\todo{Reference proof in appendix.}

\todo{Explain difference with Bryant's version?}

Let $G \in S \rightarrow (\hat Q \rightarrow \hat Q)$ and $\mathcal{G} \in (S \rightarrow \hat Q) \rightarrow (S \rightarrow \hat Q)$ be the duals of $F$ and $\mathcal{F}$ in $\hat N$, respectively. Further, let $\Psi_{*}$ be the least fix point of $\Psi = \mathcal{G}(\Psi)$ and the dual of $\Phi_{*}$ in $\hat N$.

\begin{lemma}
$\forall s \in S : \Psi_{*}(s) \enc \Phi_{*}(s)$
\end{lemma}

\subsubsection{Trajectory} A trajectory assertion $\hat A = (S,s_{0},R,\pi_{a},\pi_{c})$ for $\hat N$ where antecedents only mention inputs, $\pi_{a} \in S \rightarrow \hat I$, and consequents only mention outputs, $\pi_{c} \in S \rightarrow \hat O$, is referred to as an \textit{external trajectory assertion}. Intuitively, a satisfied external trajectory assertion is property of $N$ that must hold regardless of its internal state.

Given that $\Phi_{*}(s) \enc \Psi_{*}(s)$, and thus $\out{\Phi_{*}(s)} \sqsubseteq \out{\Psi_{*}(s)}$, for all $s \in S$, it follows that $\Phi_{*}(s) \sqcap \pi_{a}(s) \sqsubseteq \pi_{c}(s) \implies \Psi_{*}(s) \sqcap \pi_{a}(s) \sqsubseteq \pi_{c}(s)$.

\begin{theorem}
Given two abstract predicate transformers, $\hat M$ and $\hat N$, and an external trajectory assertion $\hat A$ for $\hat N$. If $\hat M \preceq \hat N$, then $\hat N \models \hat A$ implies that $\hat M \models \hat A$.
\end{theorem}

\begin{corollary}
Given two abstract predicate transformer, $\hat M$ and $\hat N = \prod \hat n_{i}$, and a trajectory assertion $\hat A$ for $\hat N$. Let $\hat N[\hat n_{i} = \hat M]$ be $\hat N$ where $\hat n_{i}$ is replaced with $\hat M$. If $\hat M \enc \hat n_{i}$ for some index $i$, then $\hat N \models \hat A$ implies that $\hat N[\hat n_{i} = \hat M] \models \hat A$.
\end{corollary}

% LocalWords:  consequents
